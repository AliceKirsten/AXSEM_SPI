/* Warning: This file is automatically generated by AX-RadioLAB.
   Manual changes are overwritten! */

#include "nbfi.h"
#include "libmfcrc.h"
#include "libmfradio.h"

// TX: fcarrier=868.775MHz dev=  0.000kHz br=  0.400kBit/s pwr= 15.0dBm
// RX: fcarrier=868.775MHz bw=  0.400kHz br=  0.400kBit/s

#define MUL8_16(x,y) ((uint8_t)((x)&0xff)*(uint16_t)(uint8_t)((y)&0xff))

#define CONSTMULFIX24(x)					\
	if (f >= 0) {						\
		uint32_t r = MUL8_16((x)>>16,f);		\
		r += MUL8_16((x)>>8,f>>8);			\
		r += MUL8_16((x),f>>16);			\
		r >>= 8;					\
		r += MUL8_16((x)>>24,f);			\
		r += MUL8_16((x)>>16,f>>8);			\
		r += MUL8_16((x)>>8,f>>16);			\
		r += MUL8_16((x),f>>24);			\
		r += ((uint32_t)MUL8_16((x)>>24,f>>8))<<8;	\
		r += ((uint32_t)MUL8_16((x)>>16,f>>16))<<8;	\
		r += ((uint32_t)MUL8_16((x)>>8,f>>24))<<8;	\
		r += ((uint32_t)MUL8_16((x)>>24,f>>16))<<16;	\
		r += ((uint32_t)MUL8_16((x)>>16,f>>24))<<16;	\
		r += ((uint32_t)MUL8_16((x)>>24,f>>24))<<24;	\
		return r;					\
	}							\
	{							\
		int32_t r;					\
		f = -f;						\
		r = -(uint32_t)MUL8_16((x)>>16,f);		\
		r -= (uint32_t)MUL8_16((x)>>8,f>>8);		\
		r -= (uint32_t)MUL8_16((x),f>>16);		\
		r >>= 8;					\
		r -= (uint32_t)MUL8_16((x)>>24,f);		\
		r -= (uint32_t)MUL8_16((x)>>16,f>>8);		\
		r -= (uint32_t)MUL8_16((x)>>8,f>>16);		\
		r -= (uint32_t)MUL8_16((x),f>>24);		\
		r -= ((uint32_t)MUL8_16((x)>>24,f>>8))<<8;	\
		r -= ((uint32_t)MUL8_16((x)>>16,f>>16))<<8;	\
		r -= ((uint32_t)MUL8_16((x)>>8,f>>24))<<8;	\
		r -= ((uint32_t)MUL8_16((x)>>24,f>>16))<<16;	\
		r -= ((uint32_t)MUL8_16((x)>>16,f>>24))<<16;	\
		r -= ((uint32_t)MUL8_16((x)>>24,f>>24))<<24;	\
		return r;					\
	}

#define CONSTMULFIX16(x)					\
	if (f >= 0) {						\
		uint32_t r = MUL8_16((x)>>16,f);		\
		r += MUL8_16((x)>>8,f>>8);			\
		r >>= 8;					\
		r += MUL8_16((x)>>24,f);			\
		r += MUL8_16((x)>>16,f>>8);			\
		r += ((uint32_t)MUL8_16((x)>>24,f>>8))<<8;	\
		return r;					\
	}							\
	{							\
		int32_t r;					\
		f = -f;						\
		r = -(uint32_t)MUL8_16((x)>>16,f);		\
		r -= (uint32_t)MUL8_16((x)>>8,f>>8);		\
		r >>= 8;					\
		r -= (uint32_t)MUL8_16((x)>>24,f);		\
		r -= (uint32_t)MUL8_16((x)>>16,f>>8);		\
		r -= ((uint32_t)MUL8_16((x)>>24,f>>8))<<8;	\
		return r;					\
	}

// physical layer
uint8_t  axradio_phy_pn9;
uint8_t  axradio_phy_nrchannels;
uint32_t  axradio_phy_chanfreq[1];
uint8_t  axradio_phy_chanpllrnginit[1];
uint8_t  axradio_phy_chanvcoiinit[1];
uint8_t  axradio_phy_chanpllrng[1];
uint8_t  axradio_phy_chanvcoi[1];
uint8_t  axradio_phy_vcocalib;
//int32_t  axradio_phy_maxfreqoffset;
//int8_t  axradio_phy_rssioffset;

//int8_t  axradio_phy_rssireference;
//int8_t  axradio_phy_channelbusy;
//uint16_t  axradio_phy_cs_period;
//uint8_t  axradio_phy_cs_enabled;
//uint8_t  axradio_phy_lbt_retries;
//uint8_t  axradio_phy_lbt_forcetx;
//uint16_t  axradio_phy_preamble_wor_longlen;
//uint16_t  axradio_phy_preamble_wor_len;
uint16_t  axradio_phy_preamble_longlen;
uint16_t  axradio_phy_preamble_len;
uint8_t  axradio_phy_preamble_byte;
uint8_t  axradio_phy_preamble_flags;
uint8_t  axradio_phy_preamble_appendbits;
uint8_t  axradio_phy_preamble_appendpattern;

//framing
uint8_t  axradio_framing_maclen;
uint8_t  axradio_framing_addrlen;
uint8_t  axradio_framing_destaddrpos;
uint8_t  axradio_framing_sourceaddrpos;
uint8_t  axradio_framing_lenpos;
uint8_t  axradio_framing_lenoffs;
uint8_t  axradio_framing_lenmask;
uint8_t  axradio_framing_swcrclen;

uint8_t  axradio_framing_synclen;
uint8_t  axradio_framing_syncword[4];
uint8_t  axradio_framing_syncflags;
//uint8_t  axradio_framing_enable_sfdcallback;

//uint32_t  axradio_framing_ack_timeout;
//uint32_t  axradio_framing_ack_delay;
//uint8_t  axradio_framing_ack_retransmissions;
//uint8_t  axradio_framing_ack_seqnrpos;

//uint8_t  axradio_framing_minpayloadlen;
//WOR
//uint16_t  axradio_wor_period;

// synchronous mode
//uint32_t  axradio_sync_period;
//uint32_t  axradio_sync_xoscstartup;
//uint32_t  axradio_sync_slave_syncwindow;
//uint32_t  axradio_sync_slave_initialsyncwindow;
//uint32_t  axradio_sync_slave_syncpause;
//int16_t  axradio_sync_slave_maxperiod;
//uint8_t  axradio_sync_slave_resyncloss;

//uint8_t  axradio_sync_slave_nrrx;
//uint32_t  axradio_sync_slave_rxadvance[3];
//uint32_t  axradio_sync_slave_rxwindow[3];
//uint32_t  axradio_sync_slave_rxtimeout;

/*---------------------------------UNB-------------------------------------*/
// physical layer
//const uint8_t  unb_axradio_phy_pn9 = 0;
const uint8_t  unb_axradio_phy_nrchannels = 1;
const uint32_t __code unb_axradio_phy_chanfreq[1] = { 0x216a17a1 };
const uint8_t __code unb_axradio_phy_chanpllrnginit[1] = { 0x0a };
const uint8_t __code unb_axradio_phy_chanvcoiinit[1] = { 0x99 };
//uint8_t  unb_axradio_phy_chanpllrng[1];
//uint8_t  unb_axradio_phy_chanvcoi[1];
//const uint8_t  unb_axradio_phy_vcocalib = 0;
//const int32_t  unb_axradio_phy_maxfreqoffset = 65;
//const int8_t  unb_axradio_phy_rssioffset = 64;

// unb_axradio_phy_rssioffset is added to AX5043_RSSIREFERENCE and subtracted from chip RSSI value to prevent overflows (8bit RSSI only goes down to -128)
// unb_axradio_phy_rssioffset is also added to AX5043_RSSIABSTHR
//const int8_t  unb_axradio_phy_rssireference = 0xFA + 64;
//const int8_t  unb_axradio_phy_channelbusy = -117 + 64;
//const uint16_t  unb_axradio_phy_cs_period = 7; // timer0 units, 10ms
//const uint8_t  unb_axradio_phy_cs_enabled = 0;
//const uint8_t  unb_axradio_phy_lbt_retries = 0;
//const uint8_t  unb_axradio_phy_lbt_forcetx = 0;
//const uint16_t  unb_axradio_phy_preamble_wor_longlen = 0; // wor_longlen + wor_len totals to 240.0ms plus 0bits
//const uint16_t  unb_axradio_phy_preamble_wor_len = 96;
//const uint16_t  unb_axradio_phy_preamble_longlen = 0;
//const uint16_t  unb_axradio_phy_preamble_len = 0;
const uint8_t  unb_axradio_phy_preamble_byte = 0xff;
const uint8_t  unb_axradio_phy_preamble_flags = 0x18;
//const uint8_t  unb_axradio_phy_preamble_appendbits = 0;
//const uint8_t  unb_axradio_phy_preamble_appendpattern = 0x00;

//framing
//const uint8_t  unb_axradio_framing_maclen = 0;
//const uint8_t  unb_axradio_framing_addrlen = 0;
//const uint8_t  unb_axradio_framing_destaddrpos = 0;
const uint8_t  unb_axradio_framing_sourceaddrpos = 0xff;
//const uint8_t  unb_axradio_framing_lenpos = 0;
const uint8_t  unb_axradio_framing_lenoffs = 136;
//const uint8_t  unb_axradio_framing_lenmask = 0x00;
//const uint8_t  unb_axradio_framing_swcrclen = 0;

const uint8_t  unb_axradio_framing_synclen = 8;
const uint8_t  unb_axradio_framing_syncword[] = { 0xff, 0xff, 0x99, 0x20};
const uint8_t  unb_axradio_framing_syncflags = 0x18;
//const uint8_t  unb_axradio_framing_enable_sfdcallback = 0;

//const uint32_t  unb_axradio_framing_ack_timeout = 85; // 130.0ms in wtimer0 units (640Hz)
//const uint32_t  unb_axradio_framing_ack_delay = 313; // 1.0ms in wtimer1 units (20MHz/64)
//const uint8_t  unb_axradio_framing_ack_retransmissions = 2;
//const uint8_t  unb_axradio_framing_ack_seqnrpos = 0xff;

//const uint8_t  unb_axradio_framing_minpayloadlen = 0; // must be set to 1 if the payload directly follows the destination address, and a CRC is configured
//WOR
//const uint16_t  unb_axradio_wor_period = 128;

// synchronous mode
//const uint32_t  unb_axradio_sync_period = 327680; // ACTUALLY FREQ, NOT PERIOD!
//const uint32_t  unb_axradio_sync_xoscstartup = 49;
//const uint32_t  unb_axradio_sync_slave_syncwindow = 983040; // 30.000s
//const uint32_t  unb_axradio_sync_slave_initialsyncwindow = 5898240; //180.000s
//const uint32_t  unb_axradio_sync_slave_syncpause = 19660800; // 600.000s
//const int16_t  unb_axradio_sync_slave_maxperiod = 5795; // in (2^SYNC_K1) * wtimer0 units
//const uint8_t  unb_axradio_sync_slave_resyncloss = 11;  // resyncloss is one more than the number of missed packets to cause a resync
// window 0 is the first window after synchronisation
// window 1 is the window normally used when there are no lost packets
// window 2 is used after one packet is lost, etc
//const uint8_t  unb_axradio_sync_slave_nrrx = 3;
//const uint32_t  unb_axradio_sync_slave_rxadvance[] = { 2685, 2535, 3336 };// 81.931ms, 77.353ms, 101.797ms
//const uint32_t  unb_axradio_sync_slave_rxwindow[] = { 3053, 2753, 4355 }; // 93.162ms, 84.006ms, 132.894ms
//const uint32_t  unb_axradio_sync_slave_rxtimeout = 89949; // 2745.0ms, maximum duration of a packet

/*---------------------------------DOWNLINK-------------------------------------*/
//const uint8_t  dl_axradio_phy_pn9 = 0;
//const uint8_t  dl_axradio_phy_nrchannels = 1;
const uint32_t  dl_axradio_phy_chanfreq[1] = { 0x11276277 };
const uint8_t  dl_axradio_phy_chanpllrnginit[1] = { 0x09 };
const uint8_t  dl_axradio_phy_chanvcoiinit[1] = { 0x97 };
//
//#ifdef GLONASS
//const uint32_t  dl_band1_axradio_phy_chanfreq[1] = { 0x21a76277 };
//const uint8_t  dl_band1_axradio_phy_chanvcoiinit[1] = { 0x98 };
//#else
//const uint32_t  dl_band1_axradio_phy_chanfreq[1] = { 0x213b13b1 };
//const uint8_t  dl_band1_axradio_phy_chanvcoiinit[1] = { 0x99 };
//#endif // GLONASS
//const uint8_t  dl_band1_axradio_phy_chanpllrnginit[1] = { 0x0a };
//
//uint8_t  dl_axradio_phy_chanpllrng[1];
//uint8_t  dl_axradio_phy_chanvcoi[1];
//const uint8_t  dl_axradio_phy_vcocalib = 0;
//const int32_t  dl_axradio_phy_maxfreqoffset = 32;
//const int8_t  dl_axradio_phy_rssioffset = 64;
//// axradio_phy_rssioffset is added to AX5043_RSSIREFERENCE and subtracted from chip RSSI value to prevent overflows (8bit RSSI only goes down to -128)
//// axradio_phy_rssioffset is also added to AX5043_RSSIABSTHR
//const int8_t  dl_axradio_phy_rssireference = 0xFA + 64;
//const int8_t  dl_axradio_phy_channelbusy = -99 + 64;
//const uint16_t  dl_axradio_phy_cs_period = 7; // timer0 units, 10ms
//const uint8_t  dl_axradio_phy_cs_enabled = 0;
//const uint8_t  dl_axradio_phy_lbt_retries = 0;
//const uint8_t  dl_axradio_phy_lbt_forcetx = 0;
//const uint16_t  dl_axradio_phy_preamble_wor_longlen = 1; // wor_longlen + wor_len totals to 240.0ms plus 328bits
//const uint16_t  dl_axradio_phy_preamble_wor_len = 96;
//const uint16_t  dl_axradio_phy_preamble_longlen = 1;
//const uint16_t  dl_axradio_phy_preamble_len = 72;
//const uint8_t  dl_axradio_phy_preamble_byte = 0x7e;
//const uint8_t  dl_axradio_phy_preamble_flags = 0x38;
//const uint8_t  dl_axradio_phy_preamble_appendbits = 0;
//const uint8_t  dl_axradio_phy_preamble_appendpattern = 0x00;
//
////framing
//const uint8_t  dl_axradio_framing_maclen = 2;
//const uint8_t  dl_axradio_framing_addrlen = 1;
//const uint8_t  dl_axradio_framing_destaddrpos = 1;
//const uint8_t  dl_axradio_framing_sourceaddrpos = 0xff;
//const uint8_t  dl_axradio_framing_lenpos = 0;
//const uint8_t  dl_axradio_framing_lenoffs = 0;
//const uint8_t  dl_axradio_framing_lenmask = 0xff;
//const uint8_t  dl_axradio_framing_swcrclen = 0;
//
//const uint8_t  dl_axradio_framing_synclen = 32;
//const uint8_t  dl_axradio_framing_syncword[] = { 0x33, 0x55, 0x33, 0x55};
//const uint8_t  dl_axradio_framing_syncflags = 0x18;
//const uint8_t  dl_axradio_framing_enable_sfdcallback = 0;
//
//const uint32_t  dl_axradio_framing_ack_timeout = 3117; // 4868.5ms in wtimer0 units (640Hz)
//const uint32_t  dl_band1_axradio_framing_ack_timeout = 3230; // 5044.5ms in wtimer0 units (640Hz)
//
//
//const uint32_t  dl_axradio_framing_ack_delay = 313; // 1.0ms in wtimer1 units (20MHz/64)
//const uint8_t  dl_axradio_framing_ack_retransmissions = 0;
//const uint8_t  dl_axradio_framing_ack_seqnrpos = 0xff;
//
//const uint8_t  dl_axradio_framing_minpayloadlen = 0; // must be set to 1 if the payload directly follows the destination address, and a CRC is configured
//const uint8_t  dl_band1_axradio_framing_minpayloadlen = 1; // must be set to 1 if the payload directly follows the destination address, and a CRC is configured
//
////WOR
//const uint16_t  dl_axradio_wor_period = 128;
//
//// synchronous mode
//const uint32_t  dl_axradio_sync_period = 191103; // ACTUALLY FREQ, NOT PERIOD!
//const uint32_t  dl_axradio_sync_xoscstartup = 49;
//const uint32_t  dl_axradio_sync_slave_syncwindow = 573309; // 17.496s
//const uint32_t  dl_axradio_sync_slave_initialsyncwindow = 5898240; //180.000s
//const uint32_t  dl_axradio_sync_slave_syncpause = 19660800; // 600.000s
//const int16_t  dl_axradio_sync_slave_maxperiod = 4047; // in (2^SYNC_K1) * wtimer0 units
//const uint8_t  dl_axradio_sync_slave_resyncloss = 11;  // resyncloss is one more than the number of missed packets to cause a resync
//// window 0 is the first window after synchronisation
//// window 1 is the window normally used when there are no lost packets
//// window 2 is used after one packet is lost, etc
//const uint8_t  dl_axradio_sync_slave_nrrx = 3;
//const uint32_t  dl_axradio_sync_slave_rxadvance[] = { 112547, 112464, 113979 };// 3434.650ms, 3432.117ms, 3478.351ms
//const uint32_t  dl_axradio_sync_slave_rxwindow[] = { 113086, 112920, 115950 }; // 3451.099ms, 3446.033ms, 3538.501ms
//const uint32_t  dl_axradio_sync_slave_rxtimeout = 148767; // 4540.0ms, maximum duration of a packet
//
//
/*----------------------------psk500_axradio-------------------------------------*/
//
//const uint8_t  psk500_axradio_phy_pn9 = 0;
//const uint8_t  psk500_axradio_phy_nrchannels = 1;
//const uint32_t  psk500_axradio_phy_chanfreq[1] = { 0x11276277 };
//const uint8_t  psk500_axradio_phy_chanpllrnginit[1] = { 0x09 };
//const uint8_t  psk500_axradio_phy_chanvcoiinit[1] = { 0x97 };
//
//const uint32_t  psk500_band1_axradio_phy_chanfreq[1] = { 0x213b13b1 };
//const uint8_t  psk500_band1_axradio_phy_chanpllrnginit[1] = { 0x0a };
//const uint8_t  psk500_band1_axradio_phy_chanvcoiinit[1] = { 0x99 };
//
//uint8_t  psk500_axradio_phy_chanpllrng[1];
//uint8_t  psk500_axradio_phy_chanvcoi[1];
//const uint8_t  psk500_axradio_phy_vcocalib = 0;
//const int32_t  psk500_axradio_phy_maxfreqoffset = 81;
//const int8_t  psk500_axradio_phy_rssioffset = 64;
//// axradio_phy_rssioffset is added to AX5043_RSSIREFERENCE and subtracted from chip RSSI value to prevent overflows (8bit RSSI only goes down to -128)
//// axradio_phy_rssioffset is also added to AX5043_RSSIABSTHR
//const int8_t  psk500_axradio_phy_rssireference = 0xFA + 64;
//const int8_t  psk500_axradio_phy_channelbusy = -99 + 64;
//const uint16_t  psk500_axradio_phy_cs_period = 7; // timer0 units, 10ms
//const uint8_t  psk500_axradio_phy_cs_enabled = 0;
//const uint8_t  psk500_axradio_phy_lbt_retries = 0;
//const uint8_t  psk500_axradio_phy_lbt_forcetx = 0;
//const uint16_t  psk500_axradio_phy_preamble_wor_longlen = 1; // wor_longlen + wor_len totals to 256.0ms plus 328bits
//const uint16_t  psk500_axradio_phy_preamble_wor_len = 136;
//const uint16_t  psk500_axradio_phy_preamble_longlen = 1;
//const uint16_t  psk500_axradio_phy_preamble_len = 72;
//const uint8_t  psk500_axradio_phy_preamble_byte = 0x7e;
//const uint8_t  psk500_axradio_phy_preamble_flags = 0x38;
//const uint8_t  psk500_axradio_phy_preamble_appendbits = 0;
//const uint8_t  psk500_axradio_phy_preamble_appendpattern = 0x00;
//
////framing
//const uint8_t  psk500_axradio_framing_maclen = 2;
//const uint8_t  psk500_axradio_framing_addrlen = 1;
//const uint8_t  psk500_axradio_framing_destaddrpos = 1;
//const uint8_t  psk500_axradio_framing_sourceaddrpos = 0xff;
//const uint8_t  psk500_axradio_framing_lenpos = 0;
//const uint8_t  psk500_axradio_framing_lenoffs = 0;
//const uint8_t  psk500_axradio_framing_lenmask = 0xff;
//const uint8_t  psk500_axradio_framing_swcrclen = 0;
//
//const uint8_t  psk500_axradio_framing_synclen = 32;
//const uint8_t  psk500_axradio_framing_syncword[] = { 0x33, 0x55, 0x33, 0x55};
//const uint8_t  psk500_axradio_framing_syncflags = 0x18;
//const uint8_t  psk500_axradio_framing_enable_sfdcallback = 0;
//
//const uint32_t  psk500_axradio_framing_ack_timeout = 1249; // 1948.9ms in wtimer0 units (640Hz)
//const uint32_t  psk500_band1_axradio_framing_ack_timeout = 1294; // 2019.3ms in wtimer0 units (640Hz)
//
//const uint32_t  psk500_axradio_framing_ack_delay = 313; // 1.0ms in wtimer1 units (20MHz/64)
//const uint8_t  psk500_axradio_framing_ack_retransmissions = 0;
//const uint8_t  psk500_axradio_framing_ack_seqnrpos = 0xff;
//
//const uint8_t  psk500_axradio_framing_minpayloadlen = 0; // must be set to 1 if the payload directly follows the destination address, and a CRC is configured
//const uint8_t  psk500_band1_axradio_framing_minpayloadlen = 1; // must be set to 1 if the payload directly follows the destination address, and a CRC is configured
//
////WOR
//const uint16_t  psk500_axradio_wor_period = 128;
//
//// synchronous mode
//const uint32_t  psk500_axradio_sync_period = 191103; // ACTUALLY FREQ, NOT PERIOD!
//const uint32_t  psk500_axradio_sync_xoscstartup = 49;
//const uint32_t  psk500_axradio_sync_slave_syncwindow = 573309; // 17.496s
//const uint32_t  psk500_axradio_sync_slave_initialsyncwindow = 5898240; //180.000s
//const uint32_t  psk500_axradio_sync_slave_syncpause = 19660800; // 600.000s
//const int16_t  psk500_axradio_sync_slave_maxperiod = 4047; // in (2^SYNC_K1) * wtimer0 units
//const uint8_t  psk500_axradio_sync_slave_resyncloss = 11;  // resyncloss is one more than the number of missed packets to cause a resync
//// window 0 is the first window after synchronisation
//// window 1 is the window normally used when there are no lost packets
//// window 2 is used after one packet is lost, etc
//const uint8_t  psk500_axradio_sync_slave_nrrx = 3;
//const uint32_t  psk500_axradio_sync_slave_rxadvance[] = { 45110, 45027, 45657 };// 1376.647ms, 1374.114ms, 1393.340ms
//const uint32_t  psk500_axradio_sync_slave_rxwindow[] = { 45354, 45188, 46448 }; // 1384.094ms, 1379.028ms, 1417.480ms
//const uint32_t  psk500_axradio_sync_slave_rxtimeout = 59507; // 1816.0ms, maximum duration of a packet
//
/*----------------------------psk5000_axradio-------------------------------------*/
//const uint8_t  psk5000_axradio_phy_pn9 = 0;
//const uint8_t  psk5000_axradio_phy_nrchannels = 1;
//const uint32_t  psk5000_axradio_phy_chanfreq[1] = { 0x11276277 };
//const uint8_t  psk5000_axradio_phy_chanpllrnginit[1] = { 0x09 };
//const uint8_t  psk5000_axradio_phy_chanvcoiinit[1] = { 0x97 };
//const uint32_t  psk5000_band1_axradio_phy_chanfreq[1] = { 0x213b13b1 };
//const uint8_t  psk5000_band1_axradio_phy_chanpllrnginit[1] = { 0x0a };
//const uint8_t  psk5000_band1_axradio_phy_chanvcoiinit[1] = { 0x99 };
//
//uint8_t  psk5000_axradio_phy_chanpllrng[1];
//uint8_t  psk5000_axradio_phy_chanvcoi[1];
//const uint8_t  psk5000_axradio_phy_vcocalib = 0;
//const int32_t  psk5000_axradio_phy_maxfreqoffset = 807;
//const int8_t  psk5000_axradio_phy_rssioffset = 64;
//// axradio_phy_rssioffset is added to AX5043_RSSIREFERENCE and subtracted from chip RSSI value to prevent overflows (8bit RSSI only goes down to -128)
//// axradio_phy_rssioffset is also added to AX5043_RSSIABSTHR
//const int8_t  psk5000_axradio_phy_rssireference = 0xF9 + 64;
//const int8_t  psk5000_axradio_phy_channelbusy = -99 + 64;
//const uint16_t  psk5000_axradio_phy_cs_period = 7; // timer0 units, 10ms
//const uint8_t  psk5000_axradio_phy_cs_enabled = 0;
//const uint8_t  psk5000_axradio_phy_lbt_retries = 0;
//const uint8_t  psk5000_axradio_phy_lbt_forcetx = 0;
//const uint16_t  psk5000_axradio_phy_preamble_wor_longlen = 3; // wor_longlen + wor_len totals to 240.0ms plus 328bits
//const uint16_t  psk5000_axradio_phy_preamble_wor_len = 160;
//const uint16_t  psk5000_axradio_phy_preamble_longlen = 1;
//const uint16_t  psk5000_axradio_phy_preamble_len = 72;
//const uint8_t  psk5000_axradio_phy_preamble_byte = 0x7e;
//const uint8_t  psk5000_axradio_phy_preamble_flags = 0x38;
//const uint8_t  psk5000_axradio_phy_preamble_appendbits = 0;
//const uint8_t  psk5000_axradio_phy_preamble_appendpattern = 0x00;
//
////framing
//const uint8_t  psk5000_axradio_framing_maclen = 2;
//const uint8_t  psk5000_axradio_framing_addrlen = 1;
//const uint8_t  psk5000_axradio_framing_destaddrpos = 1;
//const uint8_t  psk5000_axradio_framing_sourceaddrpos = 0xff;
//const uint8_t  psk5000_axradio_framing_lenpos = 0;
//const uint8_t  psk5000_axradio_framing_lenoffs = 0;
//const uint8_t  psk5000_axradio_framing_lenmask = 0xff;
//const uint8_t  psk5000_axradio_framing_swcrclen = 0;
//
//const uint8_t  psk5000_axradio_framing_synclen = 32;
//const uint8_t  psk5000_axradio_framing_syncword[] = { 0x33, 0x55, 0x33, 0x55};
//const uint8_t  psk5000_axradio_framing_syncflags = 0x18;
//const uint8_t  psk5000_axradio_framing_enable_sfdcallback = 0;
//
//const uint32_t  psk5000_axradio_framing_ack_timeout = 128; // 197.1ms in wtimer0 units (640Hz)
//const uint32_t  psk5000_band1_axradio_framing_ack_timeout = 132; // 204.2ms in wtimer0 units (640Hz)
//
//const uint32_t  psk5000_axradio_framing_ack_delay = 313; // 1.0ms in wtimer1 units (20MHz/64)
//const uint8_t  psk5000_axradio_framing_ack_retransmissions = 0;
//const uint8_t  psk5000_axradio_framing_ack_seqnrpos = 0xff;
//
//const uint8_t  psk5000_axradio_framing_minpayloadlen = 0; // must be set to 1 if the payload directly follows the destination address, and a CRC is configured
//const uint8_t  psk5000_band1_axradio_framing_minpayloadlen = 1; // must be set to 1 if the payload directly follows the destination address, and a CRC is configured
//
////WOR
//const uint16_t  psk5000_axradio_wor_period = 128;
//
//// synchronous mode
//const uint32_t  psk5000_axradio_sync_period = 191103; // ACTUALLY FREQ, NOT PERIOD!
//const uint32_t  psk5000_axradio_sync_xoscstartup = 49;
//const uint32_t  psk5000_axradio_sync_slave_syncwindow = 573309; // 17.496s
//const uint32_t  psk5000_axradio_sync_slave_initialsyncwindow = 5898240; //180.000s
//const uint32_t  psk5000_axradio_sync_slave_syncpause = 19660800; // 600.000s
//const int16_t  psk5000_axradio_sync_slave_maxperiod = 4047; // in (2^SYNC_K1) * wtimer0 units
//const uint8_t  psk5000_axradio_sync_slave_resyncloss = 11;  // resyncloss is one more than the number of missed packets to cause a resync
//// window 0 is the first window after synchronisation
//// window 1 is the window normally used when there are no lost packets
//// window 2 is used after one packet is lost, etc
//const uint8_t  psk5000_axradio_sync_slave_nrrx = 3;
//const uint32_t  psk5000_axradio_sync_slave_rxadvance[] = { 4671, 4565, 4664 };// 142.547ms, 139.313ms, 142.334ms
//const uint32_t  psk5000_axradio_sync_slave_rxwindow[] = { 4762, 4550, 4748 }; // 145.294ms, 138.825ms, 144.867ms
//const uint32_t  psk5000_axradio_sync_slave_rxtimeout = 5951; // 181.6ms, maximum duration of a packet
//
/*----------------------------FAST DOWNLINK-------------------------------------*/
//// physical layer
//const uint8_t  fastdl_axradio_phy_pn9 = 0;
//const uint8_t  fastdl_axradio_phy_nrchannels = 1;
//const uint32_t  fastdl_axradio_phy_chanfreq[1] = { 0x11276277 };
//const uint8_t  fastdl_axradio_phy_chanpllrnginit[1] = { 0x09 };
//const uint8_t  fastdl_axradio_phy_chanvcoiinit[1] = { 0x97 };
//const uint32_t  fastdl_band1_axradio_phy_chanfreq[1] = { 0x213b13b1 };
//const uint8_t  fastdl_band1_axradio_phy_chanpllrnginit[1] = { 0x0a };
//const uint8_t  fastdl_band1_axradio_phy_chanvcoiinit[1] = { 0x99 };
//
//uint8_t  fastdl_axradio_phy_chanpllrng[1];
//uint8_t  fastdl_axradio_phy_chanvcoi[1];
//const uint8_t  fastdl_axradio_phy_vcocalib = 0;
//const int32_t  fastdl_axradio_phy_maxfreqoffset = 9292;
//const int8_t  fastdl_axradio_phy_rssioffset = 64;
//// axradio_phy_rssioffset is added to AX5043_RSSIREFERENCE and subtracted from chip RSSI value to prevent overflows (8bit RSSI only goes down to -128)
//// axradio_phy_rssioffset is also added to AX5043_RSSIABSTHR
//const int8_t  fastdl_axradio_phy_rssireference = 0xF9 + 64;
//const int8_t  fastdl_axradio_phy_channelbusy = -88 + 64;
//const uint16_t  fastdl_axradio_phy_cs_period = 7; // timer0 units, 10ms
//const uint8_t  fastdl_axradio_phy_cs_enabled = 0;
//const uint8_t  fastdl_axradio_phy_lbt_retries = 0;
//const uint8_t  fastdl_axradio_phy_lbt_forcetx = 0;
//const uint16_t  fastdl_axradio_phy_preamble_wor_longlen = 28; // wor_longlen + wor_len totals to 240.0ms plus 328bits
//const uint16_t  fastdl_axradio_phy_preamble_wor_len = 72;
//const uint16_t  fastdl_axradio_phy_preamble_longlen = 1;
//const uint16_t  fastdl_axradio_phy_preamble_len = 72;
//const uint8_t  fastdl_axradio_phy_preamble_byte = 0x7e;
//const uint8_t  fastdl_axradio_phy_preamble_flags = 0x38;
//const uint8_t  fastdl_axradio_phy_preamble_appendbits = 0;
//const uint8_t  fastdl_axradio_phy_preamble_appendpattern = 0x00;
//
////framing
//const uint8_t  fastdl_axradio_framing_maclen = 2;
//const uint8_t  fastdl_axradio_framing_addrlen = 1;
//const uint8_t  fastdl_axradio_framing_destaddrpos = 1;
//const uint8_t  fastdl_axradio_framing_sourceaddrpos = 0xff;
//const uint8_t  fastdl_axradio_framing_lenpos = 0;
//const uint8_t  fastdl_axradio_framing_lenoffs = 0;
//const uint8_t  fastdl_axradio_framing_lenmask = 0xff;
//const uint8_t  fastdl_axradio_framing_swcrclen = 0;
//
//const uint8_t  fastdl_axradio_framing_synclen = 32;
//const uint8_t  fastdl_axradio_framing_syncword[] = { 0x33, 0x55, 0x33, 0x55};
//const uint8_t  fastdl_axradio_framing_syncflags = 0x18;
//const uint8_t  fastdl_axradio_framing_enable_sfdcallback = 0;
//
//const uint32_t  fastdl_axradio_framing_ack_timeout = 14; // 19.4ms in wtimer0 units (640Hz)
//const uint32_t  fastdl_axradio_framing_ack_delay = 313; // 1.0ms in wtimer1 units (20MHz/64)
//const uint8_t  fastdl_axradio_framing_ack_retransmissions = 0;
//const uint8_t  fastdl_axradio_framing_ack_seqnrpos = 0xff;
//
//const uint8_t  fastdl_axradio_framing_minpayloadlen = 1; // must be set to 1 if the payload directly follows the destination address, and a CRC is configured
////WOR
//const uint16_t  fastdl_axradio_wor_period = 128;
//
//// synchronous mode
//const uint32_t  fastdl_axradio_sync_period = 81920; // ACTUALLY FREQ, NOT PERIOD!
//const uint32_t  fastdl_axradio_sync_xoscstartup = 49;
//const uint32_t  fastdl_axradio_sync_slave_syncwindow = 245760; // 7.500s
//const uint32_t  fastdl_axradio_sync_slave_initialsyncwindow = 5898240; //180.000s
//const uint32_t  fastdl_axradio_sync_slave_syncpause = 19660800; // 600.000s
//const int16_t  fastdl_axradio_sync_slave_maxperiod = 2649; // in (2^SYNC_K1) * wtimer0 units
//const uint8_t  fastdl_axradio_sync_slave_resyncloss = 11;  // resyncloss is one more than the number of missed packets to cause a resync
//// window 0 is the first window after synchronisation
//// window 1 is the window normally used when there are no lost packets
//// window 2 is used after one packet is lost, etc
//const uint8_t  fastdl_axradio_sync_slave_nrrx = 3;
//const uint32_t  fastdl_axradio_sync_slave_rxadvance[] = { 534, 463, 517 };// 16.279ms, 14.112ms, 15.760ms
//const uint32_t  fastdl_axradio_sync_slave_rxwindow[] = { 574, 432, 540 }; // 17.500ms, 13.167ms, 16.463ms
//const uint32_t  fastdl_axradio_sync_slave_rxtimeout = 1009; // 30.8ms, maximum duration of a packet

uint8_t  axradio_phy_innerfreqloop = 1;
uint8_t  axradio_curchannel = 0;
uint16_t axradio_txbuffer_len;
uint16_t axradio_txbuffer_cnt;

volatile uint8_t  axradio_mode = AXRADIO_MODE_UNINIT;
volatile axradio_trxstate_t  axradio_trxstate = trxstate_off;
struct axradio_address_mask  axradio_localaddr;

uint8_t  axradio_txbuffer[PKTDATA_BUFLEN];
uint8_t  axradio_rxbuffer[PKTDATA_BUFLEN];


void __xdata *memset_xdata(void __xdata *p, uint8_t x, uint16_t l)
{
    uint8_t i = l >> 8;
    uint8_t j = l;
    if (!i && !j)
        return p;
    if (j)
        ++i;
    {
        uint8_t __xdata *p1 = p;
        do {
            do {
                *p1++ = x;
            } while (--j);
        } while (--i);
    }
    return p;
}

void __xdata *memcpy_xdata(void __xdata *p, const void __xdata *ps, uint16_t l)
{
    uint8_t i = l >> 8;
    uint8_t j = l;
    if (!i && !j)
        return p;
    if (j)
        ++i;
    {
        uint8_t __xdata *p1 = p;
        const uint8_t __xdata *p2 = ps;
        do {
            do {
                *p1++ = *p2++;
            } while (--j);
        } while (--i);
    }
    return p;
}

void __xdata *memcpy_xdatageneric(void __xdata *p, const void *ps, uint16_t l)
{
    uint8_t i = l >> 8;
    uint8_t j = l;
    if (!i && !j)
        return p;
    if (j)
        ++i;
    {
        uint8_t __xdata *p1 = p;
        const uint8_t *p2 = ps;
        do {
            do {
                *p1++ = *p2++;
            } while (--j);
        } while (--i);
    }
    return p;
}

void *memcpy_genericxdata(void *p, const void __xdata *ps, uint16_t l)
{
    uint8_t i = l >> 8;
    uint8_t j = l;
    if (!i && !j)
        return p;
    if (j)
        ++i;
    {
        uint8_t *p1 = p;
        const uint8_t __xdata *p2 = ps;
        do {
            do {
                *p1++ = *p2++;
            } while (--j);
        } while (--i);
    }
    return p;
}

static int16_t axradio_tunevoltage(void)
{
    int16_t r = 0;
    uint8_t cnt = 64;
    do {
        AX5043_GPADCCTRL = 0x84;
        do {} while (AX5043_GPADCCTRL & 0x80);
    } while (--cnt);
    cnt = 32;
    do {
        AX5043_GPADCCTRL = 0x84;
        do {} while (AX5043_GPADCCTRL & 0x80);
        {
            int16_t x = AX5043_GPADC13VALUE1 & 0x03;
            x <<= 8;
            x |= AX5043_GPADC13VALUE0;
            r += x;
        }
    } while (--cnt);
    return r;
}

static uint8_t axradio_adjustvcoi(uint8_t rng)
{
    uint8_t offs;
    uint8_t bestrng;
    uint16_t bestval = ~0;
    rng &= 0x7F;
    bestrng = rng;
    for (offs = 0; offs != 16; ++offs) {
        uint16_t val;
        if (!((uint8_t)(rng + offs) & 0xC0)) {
            AX5043_PLLVCOI = 0x80 | (rng + offs);
            val = axradio_tunevoltage();
            if (val < bestval) {
                bestval = val;
                bestrng = rng + offs;
            }
        }
        if (!offs)
            continue;
        if (!((uint8_t)(rng - offs) & 0xC0)) {
            AX5043_PLLVCOI = 0x80 | (rng - offs);
            val = axradio_tunevoltage();
            if (val < bestval) {
                bestval = val;
                bestrng = rng - offs;
            }
        }
    }
    // if we hit the lower rail, do not change anything
    if (bestval <= 0x0010)
        return rng | 0x80;
    return bestrng | 0x80;
}

static uint8_t axradio_calvcoi(void)
{
    uint8_t i;
    uint8_t r = 0;
    uint16_t vmin = 0xffff;
    uint16_t vmax = 0x0000;
    for (i = 0x40; i != 0;) {
        uint16_t curtune;
        --i;
        AX5043_PLLVCOI = 0x80 | i;
        AX5043_PLLRANGINGA; // clear PLL lock loss
        curtune = axradio_tunevoltage();
        AX5043_PLLRANGINGA; // clear PLL lock loss
        ((uint16_t  *)axradio_rxbuffer)[i] = curtune;
        if (curtune > vmax)
            vmax = curtune;
        if (curtune < vmin) {
            vmin = curtune;
            // check whether the PLL is locked
            if (!(0xC0 & (uint8_t)~AX5043_PLLRANGINGA))
                r = i | 0x80;
        }
    }
    if (!(r & 0x80) || vmax >= 0xFF00 || vmin < 0x0100 || vmax - vmin < 0x6000)
        return 0;
    return r;
}

uint16_t axradio_framing_append_crc(uint8_t *pkt, uint16_t cnt)
{
    uint32_t s;
    switch(nbfi_phy_channel)
    {
//    case UL_DBPSK_50:
    case UL_DBPSK_50_PROT_C:
    case UL_DBPSK_50_PROT_D:
    case UL_DBPSK_50_PROT_E:
    case UL_DBPSK_400_PROT_C:
    case UL_DBPSK_400_PROT_D:
    case UL_DBPSK_400_PROT_E:
    case UL_DBPSK_3200_PROT_D:
    case UL_DBPSK_3200_PROT_E:
        return cnt;
	case UL_PSK_200:
    case DL_PSK_200:
    case DL_PSK_FASTDL:
	case UL_PSK_FASTDL:
    case DL_PSK_500:
    case UL_PSK_500:
    case DL_PSK_5000:
    case UL_PSK_5000:
        s = 0xFFFFFFFF;
        s = crc_crc32(pkt, cnt, s);
        pkt += cnt;
        *pkt++ = ~(uint8_t)(s);
        *pkt++ = ~(uint8_t)(s >> 8);
        *pkt++ = ~(uint8_t)(s >> 16);
        *pkt++ = ~(uint8_t)(s >> 24);
        return cnt + 4;
    }
    return 0;
}

void ax5043_set_constants(void)
{
    uint8_t i = 0;

    axradio_phy_innerfreqloop = 1;
    // physical layer
//    axradio_phy_pn9 = unb_axradio_phy_pn9;
    axradio_phy_nrchannels = unb_axradio_phy_nrchannels;
    switch (nbfi_phy_channel)
    {
        case UL_DBPSK_50_PROT_C:
        case UL_DBPSK_50_PROT_D:
        case UL_DBPSK_50_PROT_E:
            axradio_phy_chanfreq[0] = unb_axradio_phy_chanfreq[0];
            axradio_phy_chanpllrnginit[0] = unb_axradio_phy_chanpllrnginit[0];
            axradio_phy_chanvcoiinit[0] = unb_axradio_phy_chanvcoiinit[0];
            break;
        case DL_DBPSK_50_PROT_D:
        case DL_DBPSK_50_PROT_E:
            axradio_phy_chanfreq[0] = dl_axradio_phy_chanfreq[0];
            axradio_phy_chanpllrnginit[0] = dl_axradio_phy_chanpllrnginit[0];
            axradio_phy_chanvcoiinit[0] = dl_axradio_phy_chanvcoiinit[0];
            break;
        default:
            break;
    }


//    axradio_phy_vcocalib = unb_axradio_phy_vcocalib;
//    axradio_phy_maxfreqoffset = unb_axradio_phy_maxfreqoffset;
//    axradio_phy_rssioffset = unb_axradio_phy_rssioffset;
//
//    axradio_phy_rssireference = unb_axradio_phy_rssireference;
//    axradio_phy_channelbusy = unb_axradio_phy_channelbusy;
//    axradio_phy_cs_period = unb_axradio_phy_cs_period;
//    axradio_phy_cs_enabled = unb_axradio_phy_cs_enabled;
//    axradio_phy_lbt_retries = unb_axradio_phy_lbt_retries;
//    axradio_phy_lbt_forcetx = unb_axradio_phy_lbt_forcetx;
//    axradio_phy_preamble_wor_longlen = unb_axradio_phy_preamble_wor_longlen;
//    axradio_phy_preamble_wor_len = unb_axradio_phy_preamble_wor_len;
//    axradio_phy_preamble_longlen = unb_axradio_phy_preamble_longlen;
//    axradio_phy_preamble_len = unb_axradio_phy_preamble_len;
    axradio_phy_preamble_byte = unb_axradio_phy_preamble_byte;
    axradio_phy_preamble_flags = unb_axradio_phy_preamble_flags;
//    axradio_phy_preamble_appendbits = unb_axradio_phy_preamble_appendbits;
//    axradio_phy_preamble_appendpattern = unb_axradio_phy_preamble_appendpattern;

    //framing
//    axradio_framing_maclen = unb_axradio_framing_maclen;
//    axradio_framing_addrlen = unb_axradio_framing_addrlen;
//    axradio_framing_destaddrpos = unb_axradio_framing_destaddrpos;
//    axradio_framing_sourceaddrpos = unb_axradio_framing_sourceaddrpos;
//    axradio_framing_lenpos = unb_axradio_framing_lenpos;
    axradio_framing_lenoffs = unb_axradio_framing_lenoffs;
//    axradio_framing_lenmask = unb_axradio_framing_lenmask;
//    axradio_framing_swcrclen = unb_axradio_framing_swcrclen;

//    axradio_framing_synclen = unb_axradio_framing_synclen;
    for(i = 0; i < 4; i++)axradio_framing_syncword[i] = unb_axradio_framing_syncword[i];
    axradio_framing_syncflags = unb_axradio_framing_syncflags;
//    axradio_framing_enable_sfdcallback = unb_axradio_framing_enable_sfdcallback;
//
//    axradio_framing_ack_timeout = unb_axradio_framing_ack_timeout;
//    axradio_framing_ack_delay = unb_axradio_framing_ack_delay;
//    axradio_framing_ack_retransmissions = unb_axradio_framing_ack_retransmissions;
//    axradio_framing_ack_seqnrpos = unb_axradio_framing_ack_seqnrpos;
//
//    axradio_framing_minpayloadlen = unb_axradio_framing_minpayloadlen;
//    //WOR
//    axradio_wor_period = unb_axradio_wor_period;
//
//    // synchronous mode
//    axradio_sync_period = unb_axradio_sync_period;
//    axradio_sync_xoscstartup = unb_axradio_sync_xoscstartup;
//    axradio_sync_slave_syncwindow = unb_axradio_sync_slave_syncwindow;
//    axradio_sync_slave_initialsyncwindow = unb_axradio_sync_slave_initialsyncwindow;
//    axradio_sync_slave_syncpause = unb_axradio_sync_slave_syncpause;
//    axradio_sync_slave_maxperiod = unb_axradio_sync_slave_maxperiod;
//    axradio_sync_slave_resyncloss = unb_axradio_sync_slave_resyncloss;
//
//    axradio_sync_slave_nrrx = unb_axradio_sync_slave_nrrx;
//    for(i = 0; i < 3; i++)axradio_sync_slave_rxadvance[i] = unb_axradio_sync_slave_rxadvance[i];
//    for(i = 0; i < 3; i++)axradio_sync_slave_rxwindow[i] = unb_axradio_sync_slave_rxwindow[i];
//    axradio_sync_slave_rxtimeout = unb_axradio_sync_slave_rxtimeout;
}

void ax5043_set_registers(void)
{
    switch(nbfi_phy_channel)
    {
//    case UL_DBPSK_50:
    case UL_DBPSK_50_PROT_C:
    case UL_DBPSK_50_PROT_D:
    case UL_DBPSK_50_PROT_E:
        AX5043_MODULATION              = 0x04;
        AX5043_ENCODING                = 0x03;
        AX5043_FRAMING                 = 0x06;
        AX5043_PINFUNCSYSCLK           = 0x04;
        AX5043_PINFUNCDCLK             = 0x01;
        AX5043_PINFUNCDATA             = 0x01;
        AX5043_PINFUNCANTSEL           = 0x82;
        AX5043_PINFUNCPWRAMP           = 0x82;
        AX5043_WAKEUPXOEARLY           = 0x01;
        AX5043_IFFREQ1                 = 0x01;
        AX5043_IFFREQ0                 = 0xFC;
        AX5043_DECIMATION              = 0x7F;
        AX5043_RXDATARATE2             = 0x00;
        AX5043_RXDATARATE1             = 0x7F;
        AX5043_RXDATARATE0             = 0xF3;
        AX5043_MAXDROFFSET2            = 0x00;
        AX5043_MAXDROFFSET1            = 0x00;
        AX5043_MAXDROFFSET0            = 0x00;
        AX5043_MAXRFOFFSET2            = 0x80;
        AX5043_MAXRFOFFSET1            = 0x00;
        AX5043_MAXRFOFFSET0            = 0x00;
        AX5043_AMPLFILTER              = 0x00;
        AX5043_RXPARAMSETS             = 0xF4;
        AX5043_AGCGAIN0                = 0xE9;
        AX5043_AGCTARGET0              = 0x84;
        AX5043_TIMEGAIN0               = 0xF9;
        AX5043_DRGAIN0                 = 0x84;
        AX5043_PHASEGAIN0              = 0x03;
        AX5043_FREQUENCYGAINA0         = 0x46;
        AX5043_FREQUENCYGAINB0         = 0x0A;
        AX5043_FREQUENCYGAINC0         = 0x1F;
        AX5043_FREQUENCYGAIND0         = 0x1F;
        AX5043_AMPLITUDEGAIN0          = 0x06;
        AX5043_FREQDEV10               = 0x00;
        AX5043_FREQDEV00               = 0x00;
        AX5043_BBOFFSRES0              = 0x00;
        AX5043_AGCGAIN1                = 0xE9;
        AX5043_AGCTARGET1              = 0x84;
        AX5043_AGCAHYST1               = 0x00;
        AX5043_AGCMINMAX1              = 0x00;
        AX5043_TIMEGAIN1               = 0xF7;
        AX5043_DRGAIN1                 = 0x83;
        AX5043_PHASEGAIN1              = 0x03;
        AX5043_FREQUENCYGAINA1         = 0x46;
        AX5043_FREQUENCYGAINB1         = 0x0A;
        AX5043_FREQUENCYGAINC1         = 0x1F;
        AX5043_FREQUENCYGAIND1         = 0x1F;
        AX5043_AMPLITUDEGAIN1          = 0x06;
        AX5043_FREQDEV11               = 0x00;
        AX5043_FREQDEV01               = 0x00;
        AX5043_FOURFSK1                = 0x16;
        AX5043_BBOFFSRES1              = 0x00;
        AX5043_AGCGAIN3                = 0xFF;
        AX5043_AGCTARGET3              = 0x84;
        AX5043_AGCAHYST3               = 0x00;
        AX5043_AGCMINMAX3              = 0x00;
        AX5043_TIMEGAIN3               = 0xF6;
        AX5043_DRGAIN3                 = 0x82;
        AX5043_PHASEGAIN3              = 0x03;
        AX5043_FREQUENCYGAINA3         = 0x46;
        AX5043_FREQUENCYGAINB3         = 0x0A;
        AX5043_FREQUENCYGAINC3         = 0x1F;
        AX5043_FREQUENCYGAIND3         = 0x1F;
        AX5043_AMPLITUDEGAIN3          = 0x06;
        AX5043_FREQDEV13               = 0x00;
        AX5043_FREQDEV03               = 0x00;
        AX5043_FOURFSK3                = 0x16;
        AX5043_BBOFFSRES3              = 0x00;
        AX5043_FSKDEV2                 = 0x00;
        AX5043_FSKDEV1                 = 0x00;
        AX5043_FSKDEV0                 = 0x00;
        AX5043_MODCFGA                 = 0x06;
        AX5043_TXPWRCOEFFB1            = 0x0F;
        AX5043_TXPWRCOEFFB0            = 0xFF;
        AX5043_PLLVCOI                 = 0x93;
        AX5043_PLLRNGCLK               = 0x04;
        AX5043_BBTUNE                  = 0x0F;
        AX5043_BBOFFSCAP               = 0x77;
        AX5043_PKTADDRCFG              = 0x80;
        AX5043_PKTLENCFG               = 0x00;
        AX5043_PKTLENOFFSET            = 0x88;
        AX5043_PKTMAXLEN               = 0xC8;
        AX5043_MATCH0PAT3              = 0xFF;
        AX5043_MATCH0PAT2              = 0x00;
        AX5043_MATCH0PAT1              = 0x00;
        AX5043_MATCH0PAT0              = 0x00;
        AX5043_MATCH0LEN               = 0x07;
        AX5043_MATCH0MAX               = 0x07;
        AX5043_MATCH1PAT1              = 0xFF;
        AX5043_MATCH1PAT0              = 0xFF;
        AX5043_MATCH1LEN               = 0x0A;
        AX5043_MATCH1MAX               = 0x0A;
        AX5043_TMGTXBOOST              = 0x3E;
        AX5043_TMGTXSETTLE             = 0x31;
        AX5043_TMGRXBOOST              = 0x3E;
        AX5043_TMGRXSETTLE             = 0x31;
        AX5043_TMGRXOFFSACQ            = 0x00;
        AX5043_TMGRXCOARSEAGC          = 0x7F;
        AX5043_TMGRXRSSI               = 0x03;
        AX5043_TMGRXPREAMBLE2          = 0x12;
        AX5043_RSSIABSTHR              = 0xCB;
        AX5043_BGNDRSSITHR             = 0x00;
        AX5043_PKTCHUNKSIZE            = 0x0D;
        AX5043_PKTACCEPTFLAGS          = 0x20;
        AX5043_DACVALUE1               = 0x00;
        AX5043_DACVALUE0               = 0x00;
        AX5043_DACCONFIG               = 0x00;
        AX5043_REF                     = 0x03;
        AX5043_XTALOSC                 = 0x04;
        AX5043_XTALAMPL                = 0x00;
        AX5043_0xF1C                   = 0x07;
        AX5043_0xF21                   = 0x68;
        AX5043_0xF22                   = 0xFF;
        AX5043_0xF23                   = 0x84;
        AX5043_0xF26                   = 0x98;
        AX5043_0xF34                   = 0x08;
        AX5043_0xF35                   = 0x12;
        AX5043_0xF44                   = 0x25;
        AX5043_MODCFGP                 = 0xE1;
        if(PSK_BAND)
        {
            AX5043_PLLVCOI                 = 0x99;
            AX5043_0xF34                   = 0x08;

        }
        else
        {
            AX5043_PLLVCOI                 = 0x97;
            AX5043_0xF34                   = 0x28;
        }
        break;
    default:
        break;
    }
}

void ax5043_set_registers_tx(void)
{
    AX5043_XTALCAP                 = 0x00;
    AX5043_0xF00                   = 0x0F;
    AX5043_0xF18                   = 0x06;

    if(PSK_BAND)
    {
        switch(nbfi_phy_channel)
        {
        case UL_DBPSK_50_PROT_C:
        case UL_DBPSK_50_PROT_D:
        case UL_DBPSK_50_PROT_E:
            AX5043_TXRATE2                 = 0x00;
            AX5043_TXRATE1                 = 0x00;
            AX5043_TXRATE0                 = 0x21;
            AX5043_PLLLOOP                 = 0x07;
            AX5043_PLLCPI                  = 0x12;
            AX5043_PLLVCODIV               = 0x20;
            break;
        case UL_DBPSK_400_PROT_C:
        case UL_DBPSK_400_PROT_D:
        case UL_DBPSK_400_PROT_E:
        case UL_PSK_200:
        case DL_PSK_200:
        case DL_PSK_500:
        case UL_PSK_500:
        case DL_PSK_5000:
        case UL_PSK_5000:
            AX5043_TXRATE2                 = 0x00;
            AX5043_TXRATE1                 = 0x00;
            AX5043_TXRATE0                 = 0x81;
            AX5043_PLLLOOP                 = 0x07;
            AX5043_PLLCPI                  = 0x12;
            AX5043_PLLVCODIV               = 0x20;
            break;
        case DL_PSK_FASTDL:
        case UL_PSK_FASTDL:
        case UL_DBPSK_3200_PROT_D:
        case UL_DBPSK_3200_PROT_E:
            AX5043_TXRATE2                 = 0x00;
            AX5043_TXRATE1                 = 0x08;
            AX5043_TXRATE0                 = 0x11;
            AX5043_PLLLOOP                 = 0x09;
            AX5043_PLLCPI                  = 0x02;
            AX5043_PLLVCODIV               = 0x20;
        default:
            break;
        }

    }
    else
    {
        switch(nbfi_phy_channel)
        {
        case UL_DBPSK_50_PROT_C:
        case UL_DBPSK_50_PROT_D:
        case UL_DBPSK_50_PROT_E:
            AX5043_TXRATE2                 = 0x00;
            AX5043_TXRATE1                 = 0x00;
            AX5043_TXRATE0                 = 0x21;
            AX5043_PLLLOOP                 = 0x07;
            AX5043_PLLCPI                  = 0x12;
            AX5043_PLLVCODIV               = 0x20;
            break;
        case UL_DBPSK_400_PROT_C:
        case UL_DBPSK_400_PROT_D:
        case UL_DBPSK_400_PROT_E:
            AX5043_TXRATE2                 = 0x00;
            AX5043_TXRATE1                 = 0x00;
            AX5043_TXRATE0                 = 0x81;
            AX5043_PLLLOOP                 = 0x07;
            AX5043_PLLCPI                  = 0x12;
            AX5043_PLLVCODIV               = 0x20;
            break;
        case UL_DBPSK_3200_PROT_D:
        case UL_DBPSK_3200_PROT_E:
            AX5043_TXRATE2                 = 0x00;
            AX5043_TXRATE1                 = 0x08;
            AX5043_TXRATE0                 = 0x11;
            AX5043_PLLLOOP                 = 0x09;
            AX5043_PLLCPI                  = 0x02;
            AX5043_PLLVCODIV               = 0x20;
            break;
        case UL_PSK_200:
        case DL_PSK_200:
        case DL_PSK_500:
        case UL_PSK_500:
        case DL_PSK_5000:
        case UL_PSK_5000:
            AX5043_TXRATE2                 = 0x00;
            AX5043_TXRATE1                 = 0x00;
            AX5043_TXRATE0                 = 0x81;
            AX5043_PLLLOOP                 = 0x0B;
            AX5043_PLLCPI                  = 0x10;
            AX5043_PLLVCODIV               = 0x24;
            break;
        case DL_PSK_FASTDL:
        case UL_PSK_FASTDL:
            AX5043_PLLLOOP                 = 0x09;
            AX5043_PLLCPI                  = 0x02;
            AX5043_PLLVCODIV               = 0x24;
        default:
            break;
        }
    }
}

void ax5043_set_registers_rx(void)
{
    if(PSK_BAND)
    {
        AX5043_PLLLOOP                 = 0x07;
        AX5043_PLLCPI                  = 0x08;
        AX5043_PLLVCODIV               = 0x20;
        AX5043_0xF18                   = 0x06;
    }
    else
    {
        switch(nbfi_phy_channel)
        {
        case UL_DBPSK_50_PROT_C:
        case UL_DBPSK_50_PROT_D:
        case UL_DBPSK_50_PROT_E:
        case UL_DBPSK_400_PROT_C:
        case UL_DBPSK_400_PROT_D:
        case UL_DBPSK_400_PROT_E:
        case UL_DBPSK_3200_PROT_D:
        case UL_DBPSK_3200_PROT_E:
            AX5043_PLLLOOP                 = 0x07;
            AX5043_PLLCPI                  = 0x08;
            AX5043_PLLVCODIV               = 0x20;
            AX5043_0xF18                   = 0x06;
            break;
        case UL_PSK_200:
        case DL_PSK_200:
        case DL_PSK_500:
        case UL_PSK_500:
        case DL_PSK_5000:
        case UL_PSK_5000:
            AX5043_PLLLOOP                 = 0x0B;
            AX5043_PLLCPI                  = 0x10;
            AX5043_PLLVCODIV               = 0x24;
            AX5043_0xF18                   = 0x02;
            break;
        case DL_PSK_FASTDL:
        case UL_PSK_FASTDL:
            AX5043_PLLLOOP                 = 0x09;
            AX5043_PLLCPI                  = 0x01;
            AX5043_PLLVCODIV               = 0x24;
            AX5043_0xF18                   = 0x02;

        default:
            break;
        }
    }
    AX5043_XTALCAP                 = 0x00;
    AX5043_0xF00                   = 0x0F;
}

 int32_t axradio_conv_freq_fromhz(int32_t f)
{
    /* scale by 0.645278 (true 0.645278) */
    uint32_t x = 0xa530e8;

    uint32_t r = MUL8_16((x)>>16,f);
    r += MUL8_16((x)>>8,f>>8);
    r += MUL8_16((x),f>>16);
    r >>= 8;
    r += MUL8_16((x)>>24,f);
    r += MUL8_16((x)>>16,f>>8);
    r += MUL8_16((x)>>8,f>>16);
    r += MUL8_16((x),f>>24);
    r += ((uint32_t)MUL8_16((x)>>24,f>>8))<<8;
    r += ((uint32_t)MUL8_16((x)>>16,f>>16))<<8;
    r += ((uint32_t)MUL8_16((x)>>8,f>>24))<<8;
    r += ((uint32_t)MUL8_16((x)>>24,f>>16))<<16;
    r += ((uint32_t)MUL8_16((x)>>16,f>>24))<<16;
    r += ((uint32_t)MUL8_16((x)>>24,f>>24))<<24;
    return r;

}

 int32_t axradio_conv_freq_tohz(int32_t f)
{
    /* scale by 1.549721 (true 1.549721) */
    uint32_t x = 0x18cba80;

    uint32_t r = MUL8_16((x)>>16,f);
    r += MUL8_16((x)>>8,f>>8);
    r += MUL8_16((x),f>>16);
    r >>= 8;
    r += MUL8_16((x)>>24,f);
    r += MUL8_16((x)>>16,f>>8);
    r += MUL8_16((x)>>8,f>>16);
    r += MUL8_16((x),f>>24);
    r += ((uint32_t)MUL8_16((x)>>24,f>>8))<<8;
    r += ((uint32_t)MUL8_16((x)>>16,f>>16))<<8;
    r += ((uint32_t)MUL8_16((x)>>8,f>>24))<<8;
    r += ((uint32_t)MUL8_16((x)>>24,f>>16))<<16;
    r += ((uint32_t)MUL8_16((x)>>16,f>>24))<<16;
    r += ((uint32_t)MUL8_16((x)>>24,f>>24))<<24;
    return r;
}


static void axradio_setaddrregs(void)
{
    AX5043_PKTADDR0 = axradio_localaddr.addr[0];
    AX5043_PKTADDR1 = axradio_localaddr.addr[1];
    AX5043_PKTADDR2 = axradio_localaddr.addr[2];
    AX5043_PKTADDR3 = axradio_localaddr.addr[3];

    AX5043_PKTADDRMASK0 = axradio_localaddr.mask[0];
    AX5043_PKTADDRMASK1 = axradio_localaddr.mask[1];
    AX5043_PKTADDRMASK2 = axradio_localaddr.mask[2];
    AX5043_PKTADDRMASK3 = axradio_localaddr.mask[3];

    if (axradio_phy_pn9 && axradio_framing_addrlen)
    {
        uint16_t pn = 0x1ff;
        uint8_t inv = -(AX5043_ENCODING & 0x01);
        if (axradio_framing_destaddrpos != 0xff)
            pn = pn9_advance_bits(pn, axradio_framing_destaddrpos << 3);
        AX5043_PKTADDR0 ^= pn ^ inv;
        pn = pn9_advance_byte(pn);
        AX5043_PKTADDR1 ^= pn ^ inv;
        pn = pn9_advance_byte(pn);
        AX5043_PKTADDR2 ^= pn ^ inv;
        pn = pn9_advance_byte(pn);
        AX5043_PKTADDR3 ^= pn ^ inv;
    }
}

static void ax5043_init_registers(void)
{
    ax5043_set_registers();

#ifdef DBGPKT
    AX5043_PINFUNCPWRAMP = 0x06; // output pwramp
#endif
    axradio_setaddrregs();
}

static  uint8_t ax5043_init_registers_common(void)
{
    uint8_t rng = axradio_phy_chanpllrng[axradio_curchannel];
    if (rng & 0x20)
        return AXRADIO_ERR_RANGING;
    if (AX5043_PLLLOOP & 0x80) {
        AX5043_PLLRANGINGB = rng & 0x0F;
    } else {
        AX5043_PLLRANGINGA = rng & 0x0F;
    }
    rng = axradio_get_pllvcoi();
    if (rng & 0x80)
        AX5043_PLLVCOI = rng;
    return AXRADIO_ERR_NOERROR;
}

static uint8_t ax5043_init_registers_tx(void)
{
    ax5043_set_registers_tx();
    return ax5043_init_registers_common();
}

uint8_t axradio_init(void)
{
    uint8_t res = 0;
    uint8_t  i;

    IE_4 = 0;
    axradio_trxstate = trxstate_off;
    res = ax5043_reset();
    if (res) return AXRADIO_ERR_NOCHIP;
    ax5043_init_registers();
    ax5043_set_registers_tx();
    AX5043_PLLLOOP = 0x09; // default 100kHz loop BW for ranging
    AX5043_PLLCPI = 0x08;

    EA = 1;
    IE_4 = 1;
    // range all channels
    AX5043_PWRMODE = AX5043_PWRSTATE_XTAL_ON;
    AX5043_MODULATION = 0x08;
	AX5043_FSKDEV2 = 0x00;
	AX5043_FSKDEV1 = 0x00;
	AX5043_FSKDEV0 = 0x00;
    axradio_wait_for_xtal();

    for (i = 0; i < axradio_phy_nrchannels; ++i)
    {
        uint8_t  iesave;
        {
            uint32_t  f = axradio_phy_chanfreq[i];
            AX5043_FREQA0 = f;
            AX5043_FREQA1 = f >> 8;
            AX5043_FREQA2 = f >> 16;
            AX5043_FREQA3 = f >> 24;
        }
        iesave = IE & 0x80;
        axradio_trxstate = trxstate_pll_ranging;
        AX5043_IRQMASK1 = 0x10; // enable pll autoranging done interrupt
        {
            uint8_t  r;
            if( !(axradio_phy_chanpllrnginit[0] & 0xF0) ) { // start values for ranging available
                r = axradio_phy_chanpllrnginit[i] | 0x10;
            }
            else {
                r = 0x18;
                if (i) {
                    r = axradio_phy_chanpllrng[i - 1];
                    if (r & 0x20)
                        r = 0x08;
                    r &= 0x0F;
                    r |= 0x10;
                }
            }
            AX5043_PLLRANGINGA = r; // init ranging process starting from "range"
        }
        while(axradio_trxstate != trxstate_pll_ranging_done);

        axradio_trxstate = trxstate_off;
        AX5043_IRQMASK1 = 0x00;
        axradio_phy_chanpllrng[i] = AX5043_PLLRANGINGA;
        IE |= iesave;
    }
    // VCOI Calibration
    if (axradio_phy_vcocalib)
    {
        ax5043_set_registers_tx();
        AX5043_MODULATION = 0x08;
        AX5043_FSKDEV2 = 0x00;
        AX5043_FSKDEV1 = 0x00;
        AX5043_FSKDEV0 = 0x00;
        AX5043_PLLLOOP |= 0x04;
        {
            uint8_t x = AX5043_0xF35;
            x |= 0x80;
            if (2 & (uint8_t)~x)
                ++x;
            AX5043_0xF35 = x;
        }
        AX5043_PWRMODE = AX5043_PWRSTATE_SYNTH_TX;
        {
            uint8_t  vcoisave = AX5043_PLLVCOI;
            uint8_t j = 2;
            for (i = 0; i < axradio_phy_nrchannels; ++i) {
                axradio_phy_chanvcoi[i] = 0;
                if (axradio_phy_chanpllrng[i] & 0x20)
                    continue;
                AX5043_PLLRANGINGA = axradio_phy_chanpllrng[i] & 0x0F;
                {
                    uint32_t  f = axradio_phy_chanfreq[i];
                    AX5043_FREQA0 = f;
                    AX5043_FREQA1 = f >> 8;
                    AX5043_FREQA2 = f >> 16;
                    AX5043_FREQA3 = f >> 24;
                }
                do {
                    if (axradio_phy_chanvcoiinit[0]) {
                        uint8_t x = axradio_phy_chanvcoiinit[i];
                        if (!(axradio_phy_chanpllrnginit[0] & 0xF0))
                            x += (axradio_phy_chanpllrng[i] & 0x0F) - (axradio_phy_chanpllrnginit[i] & 0x0F);
                        axradio_phy_chanvcoi[i] = axradio_adjustvcoi(x);
                    } else {
                        axradio_phy_chanvcoi[i] = axradio_calvcoi();
                    }
                } while (--j);
                j = 1;
            }
            AX5043_PLLVCOI = vcoisave;
        }
    }
    AX5043_PWRMODE = AX5043_PWRSTATE_POWERDOWN;
    ax5043_init_registers();
    ax5043_set_registers_rx();
    AX5043_PLLRANGINGA = axradio_phy_chanpllrng[0] & 0x0F;
    {
        uint32_t  f = axradio_phy_chanfreq[0];
        AX5043_FREQA0 = f;
        AX5043_FREQA1 = f >> 8;
        AX5043_FREQA2 = f >> 16;
        AX5043_FREQA3 = f >> 24;
    }

    axradio_mode = AXRADIO_MODE_OFF;
    for (i = 0; i < axradio_phy_nrchannels; ++i)
        if (axradio_phy_chanpllrng[i] & 0x20)
            return AXRADIO_ERR_RANGING;
    return AXRADIO_ERR_NOERROR;
}

uint8_t axradio_set_mode(uint8_t mode)
{
    if (mode == axradio_mode)
        return AXRADIO_ERR_NOERROR;
    switch (axradio_mode) {
    case AXRADIO_MODE_UNINIT:
    {
        uint8_t  r = axradio_init();
        if (r != AXRADIO_ERR_NOERROR)
            return r;
        break;
    }
    case AXRADIO_MODE_OFF:
        break;
    default:
        ax5043_off();
        axradio_mode = AXRADIO_MODE_OFF;
        break;
    }

    if (mode == AXRADIO_MODE_UNINIT)
        return AXRADIO_ERR_NOTSUPPORTED;

    switch (mode) {
    case AXRADIO_MODE_OFF:
        return AXRADIO_ERR_NOERROR;

    case AXRADIO_MODE_ASYNC_TRANSMIT:
    case AXRADIO_MODE_ACK_TRANSMIT:
        axradio_mode = mode;
        ax5043_init_registers_tx();
        return AXRADIO_ERR_NOERROR;

    case AXRADIO_MODE_CW_TRANSMIT:
        axradio_mode = AXRADIO_MODE_CW_TRANSMIT;
        ax5043_init_registers_tx();
        AX5043_MODULATION = 8;   // Set an FSK mode
        AX5043_FSKDEV2 = 0x00;
        AX5043_FSKDEV1 = 0x00;
        AX5043_FSKDEV0 = 0x00;
        AX5043_TXRATE2 = 0x00;
        AX5043_TXRATE1 = 0x00;
        AX5043_TXRATE0 = 0x01;
        AX5043_PINFUNCDATA = 0x04;
        AX5043_PWRMODE = AX5043_PWRSTATE_FIFO_ON;
        axradio_trxstate = trxstate_txcw_xtalwait;
        AX5043_IRQMASK0 = 0x00;
        AX5043_IRQMASK1 = 0x01; // enable xtal ready interrupt
        return AXRADIO_ERR_NOERROR;

    default:
        return AXRADIO_ERR_NOTSUPPORTED;
    }
}

 void ax5043_off(void)
{
    AX5043_IRQMASK0 = 0x00; // IRQ off
    AX5043_IRQMASK1 = 0x00;
    AX5043_PWRMODE = AX5043_PWRSTATE_XTAL_ON;
    AX5043_LPOSCCONFIG = 0x00; // LPOSC off
    AX5043_PWRMODE = AX5043_PWRSTATE_POWERDOWN;

    axradio_trxstate = trxstate_off;
}

void axradio_set_local_address(const struct axradio_address_mask *addr)
{
    memcpy_xdatageneric(&axradio_localaddr, addr, sizeof(axradio_localaddr));
    axradio_setaddrregs();
}

void axradio_get_local_address(struct axradio_address_mask *addr)
{
    memcpy_genericxdata(addr, &axradio_localaddr, sizeof(axradio_localaddr));
}

void ax5043_prepare_tx(void)
{
    AX5043_PWRMODE = AX5043_PWRSTATE_XTAL_ON;
    AX5043_PWRMODE = AX5043_PWRSTATE_FIFO_ON;
    ax5043_init_registers_tx();
    AX5043_FIFOTHRESH1 = 0;
    AX5043_FIFOTHRESH0 = 0x80;
    axradio_trxstate = trxstate_tx_xtalwait;
    AX5043_IRQMASK0 = 0x00;
    AX5043_IRQMASK1 = 0x01; // enable xtal ready interrupt
    AX5043_POWSTICKYSTAT; // clear pwr management sticky status --> brownout gate works
}

uint8_t axradio_transmit(const struct axradio_address *addr, const uint8_t *pkt, uint16_t pktlen, uint8_t padding)
{
    uint16_t n, j;

    switch (axradio_mode)
    {
        case AXRADIO_MODE_ASYNC_TRANSMIT:
        case AXRADIO_MODE_WOR_TRANSMIT:
        case AXRADIO_MODE_ACK_TRANSMIT:
        case AXRADIO_MODE_WOR_ACK_TRANSMIT:
            axradio_txbuffer_len = (padding?(pktlen*4):(pktlen)) + axradio_framing_maclen;
            if (axradio_txbuffer_len > sizeof(axradio_txbuffer))
                return AXRADIO_ERR_INVALID;
            memset_xdata(axradio_txbuffer, 0, axradio_framing_maclen);

            if(padding)
            {
                for(n = 0; n < pktlen; n++)
                {
                    for(j = 0; j < 4; j++)
                    {
                        axradio_txbuffer[(4*n)+j] = 0x77 | ((pkt[n]<<(2*j))&0x80) | (((pkt[n]<<(2*j+1)) >> 4)&0x08);
                    }
                }
            }
            else memcpy_xdatageneric(&axradio_txbuffer[axradio_framing_maclen], pkt, pktlen);

//            if (axradio_framing_destaddrpos != 0xff)
//                memcpy_xdatageneric(&axradio_txbuffer[axradio_framing_destaddrpos], &addr->addr, axradio_framing_addrlen);
//            if (axradio_framing_sourceaddrpos != 0xff)
//                memcpy_xdata(&axradio_txbuffer[axradio_framing_sourceaddrpos], &axradio_localaddr.addr, axradio_framing_addrlen);
//            if (axradio_framing_lenmask) {
//                uint8_t len_byte = (uint8_t)(axradio_txbuffer_len - axradio_framing_lenoffs) & axradio_framing_lenmask; // if you prefer not counting the len byte itself, set LENOFFS = 1
//                axradio_txbuffer[axradio_framing_lenpos] = (axradio_txbuffer[axradio_framing_lenpos] & (uint8_t)~axradio_framing_lenmask) | len_byte;
//            }
//            if (axradio_framing_swcrclen)
//                axradio_txbuffer_len = axradio_framing_append_crc(axradio_txbuffer, axradio_txbuffer_len);
//            if (axradio_phy_pn9)
//                pn9_buffer(axradio_txbuffer, axradio_txbuffer_len, 0x1ff, -(AX5043_ENCODING & 0x01));

            axradio_txbuffer_cnt = axradio_phy_preamble_longlen;

            ax5043_prepare_tx();
            return AXRADIO_ERR_NOERROR;

        default:
            return AXRADIO_ERR_NOTSUPPORTED;
    }
}

void axradio_wait_for_xtal(void)
{
    uint8_t  iesave = IE & 0x80;
    axradio_trxstate = trxstate_wait_xtal;
    AX5043_IRQMASK1 |= 0x01; // enable xtal ready interrupt
    while (axradio_trxstate != trxstate_xtal_ready);
    IE |= iesave;

}

uint8_t axradio_get_pllvcoi(void)
{
    if (axradio_phy_vcocalib) {
        uint8_t x = axradio_phy_chanvcoi[axradio_curchannel];
        if (x & 0x80)
            return x;
    }
    {
        uint8_t x = axradio_phy_chanvcoiinit[axradio_curchannel];
        if (x & 0x80) {
            if (!(axradio_phy_chanpllrnginit[0] & 0xF0)) {
                x += (axradio_phy_chanpllrng[axradio_curchannel] & 0x0F) - (axradio_phy_chanpllrnginit[axradio_curchannel] & 0x0F);
                x &= 0x3f;
                x |= 0x80;
            }
            return x;
        }
    }
    return AX5043_PLLVCOI;
}

static void transmit_isr(void)
{
    for (;;)
    {
        uint8_t cnt = AX5043_FIFOFREE0;
        if (AX5043_FIFOFREE1)
            cnt = 0xff;
        switch (axradio_trxstate)
        {
            case trxstate_tx_longpreamble:
                if (!axradio_txbuffer_cnt)
                {
                    axradio_trxstate = trxstate_tx_shortpreamble;
                    axradio_txbuffer_cnt = axradio_phy_preamble_len;
                    goto shortpreamble;
                }
                if (cnt < 4)
                    goto fifocommit;
                cnt = 7;
                if (axradio_txbuffer_cnt < 7)
                    cnt = axradio_txbuffer_cnt;
                axradio_txbuffer_cnt -= cnt;
                cnt <<= 5;
                AX5043_FIFODATA = AX5043_FIFOCMD_REPEATDATA | (3 << 5);
                AX5043_FIFODATA = axradio_phy_preamble_flags;
                AX5043_FIFODATA = cnt;
                AX5043_FIFODATA = axradio_phy_preamble_byte;
                break;

            case trxstate_tx_shortpreamble:
            shortpreamble:
                if (!axradio_txbuffer_cnt)
                {
                    if (cnt < 15)
                        goto fifocommit;
                    if (axradio_phy_preamble_appendbits)
                    {
                        uint8_t byte;
                        AX5043_FIFODATA = AX5043_FIFOCMD_DATA | (2 << 5);
                        AX5043_FIFODATA = 0x1C;
                        byte = axradio_phy_preamble_appendpattern;
                        if (AX5043_PKTADDRCFG & 0x80)
                        {
                            // msb first -> stop bit below
                            byte &= 0xFF << (8-axradio_phy_preamble_appendbits);
                            byte |= 0x80 >> axradio_phy_preamble_appendbits;
                        }
                        else
                        {
                             // lsb first -> stop bit above
                            byte &= 0xFF >> (8-axradio_phy_preamble_appendbits);
                            byte |= 0x01 << axradio_phy_preamble_appendbits;
                        }
                        AX5043_FIFODATA = byte;
                    }
#ifdef DBGPKT
                AX5043_FIFODATA = AX5043_FIFOCMD_TXCTRL | (1 << 5);
                AX5043_FIFODATA = 0x02; // set PA, state 0
#endif
                if ((AX5043_FRAMING & 0x0E) == 0x06 && axradio_framing_synclen)
                {
                    // write SYNC word if framing mode is raw_patternmatch, might use SYNCLEN > 0 as a criterion, but need to make sure SYNCLEN=0 for WMBUS (chip automatically sends SYNCWORD but matching in RX works via MATCH0PAT)
                    uint8_t len_byte = axradio_framing_synclen;
                    uint8_t i = (len_byte & 0x07) ? 0x04 : 0;
                    // SYNCLEN in bytes, rather than bits. Ceiled to next integer e.g. fractional bits are counted as full bits;
                    len_byte += 7;
                    len_byte >>= 3;
                    AX5043_FIFODATA = AX5043_FIFOCMD_DATA | ((len_byte + 1) << 5);
                    AX5043_FIFODATA = axradio_framing_syncflags | i;
                    for (i = 0; i < len_byte; ++i)
                    {
                        // better put a brace, it might prevent SDCC from optimizing away the assignement...
                        AX5043_FIFODATA = axradio_framing_syncword[i];
                    }
                }
#ifdef DBGPKT
                AX5043_FIFODATA = AX5043_FIFOCMD_TXCTRL | (1 << 5);
                AX5043_FIFODATA = 0x03; // set PA, state 1
#endif
                axradio_trxstate = trxstate_tx_packet;
                break;
            }
            if (cnt < 4)
                goto fifocommit;
            cnt = 255;
            if (axradio_txbuffer_cnt < 255*8)
                cnt = axradio_txbuffer_cnt >> 3;
            if (cnt) {
                axradio_txbuffer_cnt -= ((uint16_t)cnt) << 3;
                AX5043_FIFODATA = AX5043_FIFOCMD_REPEATDATA | (3 << 5);
                AX5043_FIFODATA = axradio_phy_preamble_flags;
                AX5043_FIFODATA = cnt;
                AX5043_FIFODATA = axradio_phy_preamble_byte;
                break;
            }
            {
                uint8_t byte = axradio_phy_preamble_byte;
                cnt = axradio_txbuffer_cnt;
                axradio_txbuffer_cnt = 0;
                AX5043_FIFODATA = AX5043_FIFOCMD_DATA | (2 << 5);
                AX5043_FIFODATA = 0x1C;
                if (AX5043_PKTADDRCFG & 0x80) {
                    // msb first -> stop bit below
                    byte &= 0xFF << (8-cnt);
                    byte |= 0x80 >> cnt;
                } else {
                     // lsb first -> stop bit above
                    byte &= 0xFF >> (8-cnt);
                    byte |= 0x01 << cnt;
                }
                AX5043_FIFODATA = byte;
            }
            break;

        case trxstate_tx_packet:
            if (cnt < 11)
                goto fifocommit;
            {
                uint8_t flags = 0;
                if (!axradio_txbuffer_cnt)
                    flags |= 0x01; // flag byte: pkt_start
                {
                    uint16_t len = axradio_txbuffer_len - axradio_txbuffer_cnt;
                    cnt -= 3;
                    if (cnt >= len) {
                        cnt = len;
                        flags |= 0x02; // flag byte: pkt_end
                    }
                }
                if (!cnt)
                    goto pktend;
                AX5043_FIFODATA = AX5043_FIFOCMD_DATA | (7 << 5);
                AX5043_FIFODATA = cnt + 1; // write FIFO chunk length byte (length includes the flag byte, thus the +1)
                AX5043_FIFODATA = flags;
                ax5043_writefifo(&axradio_txbuffer[axradio_txbuffer_cnt], cnt);
                axradio_txbuffer_cnt += cnt;
                if (flags & 0x02)
                    goto pktend;
            }
            break;

        default:
            return;
        }
    }
pktend:
    axradio_trxstate = trxstate_tx_waitdone;
    AX5043_RADIOEVENTMASK0 = 0x01; // enable REVRDONE event
    AX5043_IRQMASK0 = 0x40; // enable radio controller irq
fifocommit:
    AX5043_FIFOSTAT = 4; // commit
}

#if defined SDCC
void axradio_isr(void) __interrupt INT_RADIO
#elif defined __CX51__ || defined __C51__
 void axradio_isr(void) interrupt INT_RADIO
#elif defined __ICC8051__
#pragma vector=0x23
__interrupt void axradio_isr(void)
#else
#warning "Compiler unsupported"
#endif
{
    switch (axradio_trxstate) {
    default:
        AX5043_IRQMASK1 = 0x00;
        AX5043_IRQMASK0 = 0x00;
        break;

    case trxstate_wait_xtal:
        AX5043_IRQMASK1 = 0x00; // otherwise crystal ready will fire all over again
        axradio_trxstate = trxstate_xtal_ready;
        break;

    case trxstate_pll_ranging:
        AX5043_IRQMASK1 = 0x00; // otherwise autoranging done will fire all over again
        axradio_trxstate = trxstate_pll_ranging_done;
        break;

    case trxstate_pll_settling:
        AX5043_RADIOEVENTMASK0 = 0x00;
        axradio_trxstate = trxstate_pll_settled;
        break;

    case trxstate_tx_xtalwait:
        AX5043_RADIOEVENTREQ0; // make sure REVRDONE bit is cleared, so it is a reliable indicator that the packet is out
        AX5043_FIFOSTAT = 3; // clear FIFO data & flags (prevent transmitting anything left over in the FIFO, this has no effect if the FIFO is not powerered, in this case it is reset any way)
        AX5043_IRQMASK1 = 0x00;
        AX5043_IRQMASK0 = 0x08; // enable fifo free threshold
        if (axradio_phy_preamble_longlen) axradio_trxstate = trxstate_tx_longpreamble;
        else axradio_trxstate = trxstate_tx_packet;
#ifdef DBGPKT
        AX5043_FIFODATA = AX5043_FIFOCMD_TXCTRL | (1 << 5);
        AX5043_FIFODATA = 0x03; // set PA, state 1
#endif
        AX5043_PWRMODE = AX5043_PWRSTATE_FULL_TX;
        transmit_isr();
        break;

    case trxstate_tx_longpreamble:
    case trxstate_tx_shortpreamble:
    case trxstate_tx_packet:
        transmit_isr();
        break;

    case trxstate_tx_waitdone:
        AX5043_RADIOEVENTREQ0;
        if (AX5043_RADIOSTATE != 0)
            break;
        AX5043_RADIOEVENTMASK0 = 0x00;
        axradio_trxstate = trxstate_tx_done;
//        switch (axradio_mode) {
//        case AXRADIO_MODE_ASYNC_RECEIVE:
//            ax5043_init_registers_rx();
//            ax5043_receiver_on_continuous();
//            break;
//
//        case AXRADIO_MODE_ACK_RECEIVE:
//            if (axradio_cb_receive.st.error == AXRADIO_ERR_PACKETDONE) {
//                ax5043_init_registers_rx();
//                ax5043_receiver_on_continuous();
//                break;
//            }
//        offxtal:
//            ax5043_off_xtal();
//            break;
//
////        case AXRADIO_MODE_WOR_RECEIVE:
////            if (axradio_cb_receive.st.error == AXRADIO_ERR_PACKETDONE) {
////                ax5043_init_registers_rx();
////                ax5043_receiver_on_wor();
////                break;
////            }
////            goto offxtal;
////
////        case AXRADIO_MODE_WOR_ACK_RECEIVE:
////            ax5043_init_registers_rx();
////            ax5043_receiver_on_wor();
////            break;
//
//        case AXRADIO_MODE_SYNC_ACK_MASTER:
//            axradio_txbuffer_len = axradio_framing_minpayloadlen;
//            // fall through
//
//        case AXRADIO_MODE_ACK_TRANSMIT:
//        case AXRADIO_MODE_WOR_ACK_TRANSMIT:
//            ax5043_init_registers_rx();
//            ax5043_receiver_on_continuous();
//            wtimer_remove(&axradio_timer);
//            axradio_timer.time = axradio_framing_ack_timeout;
//            wtimer0_addrelative(&axradio_timer);
//            break;
//
//        case AXRADIO_MODE_SYNC_MASTER:
//            axradio_txbuffer_len = axradio_framing_minpayloadlen;
//            // fall through
//
//        default:
//            ax5043_off();
//            break;
//        }
//        if (axradio_mode != AXRADIO_MODE_SYNC_MASTER &&
//            axradio_mode != AXRADIO_MODE_SYNC_ACK_MASTER &&
//            axradio_mode != AXRADIO_MODE_SYNC_SLAVE &&
//            axradio_mode != AXRADIO_MODE_SYNC_ACK_SLAVE)
//            axradio_syncstate = syncstate_off;
//        update_timeanchor();
//        wtimer_remove_callback(&axradio_cb_transmitend.cb);
//        axradio_cb_transmitend.st.error = AXRADIO_ERR_NOERROR;
//        if (axradio_mode == AXRADIO_MODE_ACK_TRANSMIT ||
//            axradio_mode == AXRADIO_MODE_WOR_ACK_TRANSMIT ||
//            axradio_mode == AXRADIO_MODE_SYNC_ACK_MASTER)
//            axradio_cb_transmitend.st.error = AXRADIO_ERR_BUSY;
//        axradio_cb_transmitend.st.time.t = axradio_timeanchor.radiotimer;
//        wtimer_add_callback(&axradio_cb_transmitend.cb);
        break;

    case trxstate_txcw_xtalwait:
        AX5043_IRQMASK1 = 0x00;
        AX5043_IRQMASK0 = 0x00;
        AX5043_PWRMODE = AX5043_PWRSTATE_FULL_TX;
        axradio_trxstate = trxstate_off;
        //update_timeanchor();
        //wtimer_remove_callback(&axradio_cb_transmitstart.cb);
        //axradio_cb_transmitstart.st.error = AXRADIO_ERR_NOERROR;
        //axradio_cb_transmitstart.st.time.t = axradio_timeanchor.radiotimer;
        //wtimer_add_callback(&axradio_cb_transmitstart.cb);
        break;

//    case trxstate_txstream_xtalwait:
//        if (AX5043_IRQREQUEST1 & 0x01) {
//            AX5043_RADIOEVENTMASK0 = 0x03; // enable PLL settled and done event
//            AX5043_IRQMASK1 = 0x00;
//            AX5043_IRQMASK0 = 0x40; // enable radio controller irq
//            AX5043_PWRMODE = AX5043_PWRSTATE_FULL_TX;
//            axradio_trxstate = trxstate_txstream;
//        }
//        goto txstreamdatacb;
//
//    case trxstate_txstream:
//        {
//            uint8_t  evt = AX5043_RADIOEVENTREQ0;
//            if (evt & 0x03)
//                update_timeanchor();
//            if (evt & 0x01) {
//                wtimer_remove_callback(&axradio_cb_transmitend.cb);
//                axradio_cb_transmitend.st.error = AXRADIO_ERR_NOERROR;
//                axradio_cb_transmitend.st.time.t = axradio_timeanchor.radiotimer;
//                wtimer_add_callback(&axradio_cb_transmitend.cb);
//            }
//            if (evt & 0x02) {
//                wtimer_remove_callback(&axradio_cb_transmitstart.cb);
//                axradio_cb_transmitstart.st.error = AXRADIO_ERR_NOERROR;
//                axradio_cb_transmitstart.st.time.t = axradio_timeanchor.radiotimer;
//                wtimer_add_callback(&axradio_cb_transmitstart.cb);
//            }
//        }
//    txstreamdatacb:
//        if (AX5043_IRQREQUEST0 & AX5043_IRQMASK0 & 0x08) {
//            AX5043_IRQMASK0 &= (uint8_t)~0x08;
//            update_timeanchor();
//            wtimer_remove_callback(&axradio_cb_transmitdata.cb);
//            axradio_cb_transmitdata.st.error = AXRADIO_ERR_NOERROR;
//            axradio_cb_transmitdata.st.time.t = axradio_timeanchor.radiotimer;
//            wtimer_add_callback(&axradio_cb_transmitdata.cb);
//        }
//        break;
//
//    case trxstate_rxwor:
//        //F143_WOR_TCXO
//        //AX8052F143, WOR with TCXO: MCU needs to wake up upon TCXO enable / disable in order to get the TCXO_EN singal into the frozen GPIO
//        if( AX5043_IRQREQUEST0 & 0x80 ) // vdda ready (note irqinversion does not act upon AX5043_IRQREQUEST0)
//        {
//            AX5043_IRQINVERSION0 |= 0x80; // invert pwr irq, so it does not fire continuously
//        }
//        else
//        {
//            AX5043_IRQINVERSION0 &= (uint8_t)~0x80; // drop pwr irq inversion --> armed again
//        }
//
//
//        if( AX5043_IRQREQUEST1 & 0x01 ) // XTAL ready
//        {
//            AX5043_IRQINVERSION1 |= 0x01; // invert the xtal ready irq so it does not fire continuously
//        }
//        else // XTAL not running
//        {
//            AX5043_IRQINVERSION1 &= (uint8_t)~0x01; // drop xtal ready irq inversion --> armed again for next wake-up
//            AX5043_0xF30 = f30_saved;
//            AX5043_0xF31 = f31_saved;
//            AX5043_0xF32 = f32_saved;
//            AX5043_0xF33 = f33_saved;
//        }
//
//    // fall through
//    case trxstate_rx:
//        receive_isr();
//        break;

    } // end switch(axradio_trxstate)
} //end radio_isr
